
<html>
  <head>
    <script src="dist/parser.js"></script>
    <script src="test/parser_test.js"></script>
    <script src="dist/runtime.js"></script>
    <script src="test/runtime_test.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  </head>
    <body>
      <div id="intro">
        <h1> Pounce </h1>
        <p>Pounce is a stack based, concatanative programming language. Pounce returns the accessability of this style of development any type of computer:</p>
        <ul><li><em>the Web</em> -- In your browser you can try it out, see examples and do quite advanced things with Pounce.</li>
            <li><em>server-side</em> -- Your server (or any computer that can run python,) can run Pounce (interpreted in Python works now with plans to port it to compiled languages).  </li>
            <li><em>microprocessors</em> -- From Arduino to M0-4 processors You have choices of running Pounce interpretors written in 'C' or if you can run python, you can try the Pounce environment written in Python.</li>
        </ul>
        <p>Pounce takes after 'Forth', 'Joy' and 'Cat' which are all very different language from the main-stream programming laguages that you know, but differnet approach is not new. Concatinative languages have evolved over the last {{ pounce(' 1970 years-since 1 - 10 / floor 10 * ') }} plus years. 'Forth' is now {{ pounce('1970 years-since') }} years old, but it does not look or feel old. All these languages have aged well, in part because of simplicity, which has been mostly squandered in all other programming languages.</p>
        <p>Simplicity was the primary motivation behind all of these languages. First of all: These languages have almost a complete lack of syntax, so that reduces what you must learn. Second, Post-fix notation or (or RPN) is used to eliminate the need for brackets and parenthasis for blocks and control struture. Yeup, post-fix is strange and for the first ten minutes it will seem backwards*, but latter you will see some very legitimate reasons for its use, we promice.</p>
        <p>* Of Course 'Backwards' is in the eye of the beholder, Looking at these two code snipits of a bowling game, I ask you, which seems more 'backwards?'</p>
<pre>
  roleBallAt(Pins.set(TEN_PINS));
  
  TEN_PINS Pins.set roleBallAt
</pre>
        <p>The first is similar to your usual fimiliar programming langage. The verbs (or actions) come first and the nouns come second. We are accustumed to this, but think about running a real bowling ally and what it takes to execute this code. It would be backwards to start at the left of the script and <em>roll a ball</em> at pins that had not been <em>set up</em> yet. The second example is in post-fix notation and it starts with the nouns and ends with verbs. It reads from left to right, <em>with ten pins, set them up</em> and then <em>role a ball</em> at them. It takes some getting used to, but the question of which one is backwards, may flip for you. [through the looking glass]</p>
      </div>
        <h2> Pounce Tests </h2>
        <div id="testing">
          <p>Test driven development is good practice for a Pounce developer and also for the development of Pounce itself. So here we go, first we test the Pounce parser and then the Pounce runtime. </p>
          <button v-on:click="showParserTests = !showParserTests">toggle parser test results</button> Out of {{ total_tests }} tests, {{ failed_tests }} tests failed.
          <table id="parser_testing" v-show="showParserTests">
            <tr v-for="t in parser_tests">
              <td><code>{{t[0]}}</code></td><td><code>{{t[1]}}</code></td><td>{{ (t[2])? 'passed': 'failed' }}</td><td><code>{{t[3]}}</code></td>
            </tr>
          </table>
          <button v-on:click="showRuntimeTests = !showRuntimeTests">toggle Runtime test results</button> Out of {{ totalRuntime_tests }} tests, {{ failedRuntime_tests }} tests failed.
          <table id="runtime_testing" v-show="showRuntimeTests">
            <tr v-for="t in runtime_tests">
              <td><code>{{t[0]}}</code></td><td><code>{{t[1]}}</code></td><td>{{ (t[2])? 'passed': 'failed' }}</td><td><code>{{t[3]}}</code></td>
            </tr>
          </table>
        </div>
        <div id="try_pounce">
          Try the Pounce by entering some Pounce code: <br/>
          <input v-model="ps" v-on:keyup="runPounce()" /> <br/>
          and the Pounce output: <br/>
          {{ pl }}
          {{ words }}
          <div v-for="ele in vs">
            {{ ele }}
          </div>
        </div>
        <script>
          var date_now = new Date();
          words['years-since'] = parse(date_now.getFullYear() + ' - -1 *');
          words['floor'] = (s, pl) => {
            const num = s.pop();
            s.push(Math.floor(num));
            return [s, pl];
          };
          var intro = new Vue({
            el: '#intro',
            data: {
              "pounce": (ps) => run(parse(ps), [], words)[0]
            }
          });
          var testing = new Vue({
            el: '#testing',
            data: {
              "showParserTests": false
            , "parser_tests": parser_tests
            , "total_tests": parser_tests.length
            , "failed_tests": parser_tests.reduce(function (acc, o, i) { if (!o[2]) {return acc+1;} return acc; }, 0),
              "showRuntimeTests": false
            , "runtime_tests": runtime_tests
            , "totalRuntime_tests": runtime_tests.length
            , "failedRuntime_tests": runtime_tests.reduce(function (acc, o, i) { if (!o[2]) {return acc+1;} return acc; }, 0)
            }
          });
          var try_pounce = new Vue({
            el: '#try_pounce',
            data: {
              "ps": ""
            , "pl": []
            , "vs": []
            , "words": words
            , "runPounce": function () {
              this.pl = parse(this.ps);
              this.vs = run(this.pl, [], words).reverse();
            }
            }
          });
        </script>
    </body>
</html>
