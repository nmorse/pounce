// pounce parser (in pounce)
//// definitions

[ dup 0 > [1 - swap dup dip2 swap repeat] [drop drop] if-else ] [repeat] def

[[ps set] dip [cw get] dip str-append cw set 'word' state set] [word-proc] def

[drop ps set pl get [cw get] dip swap push pl set ' ' cw set true] [word-end] def

[drop dup 'list' state set my-parse] [list-proc] def

[ps get str-first dup {' ':[word-end] '[':list-proc} case not [word-proc] if] [parse-ps-to-pl] def

[get str-length 0 == not] [has-content] def

[dup [swap] dip swap ps has-content [cw has-content] dip or [swap [swap until-ps-cw-and-empty] push apply apply] if] [until-ps-cw-and-empty] def

{ps:'this is [ a sample 1 ] to parse' pl:[] state:'?' cw:''} [parse-ps-to-pl] until-ps-cw-and-empty






// test of until-ps-empty
[dup [swap] dip swap ps get str-length 0 == not [swap [swap until-ps-empty] push apply apply] if] [until-ps-empty] def
[ps get str-first drop ps set] [do] def
{ps:'1 2 3' } [do] until-ps-empty


// test of until-ps-empty
[dup [swap] dip swap ps get str-length 0 == not [cw get str-length 0 == not] dip and [swap [swap until-ps-cw-and-empty] push apply apply] if] [until-ps-cw-and-empty] def
[ps get str-first drop ps set] [do] def
{ps:'1 2 3' cw:'' } [do] until-ps-cw-and-empty